# a915: 二维点排序

## 1、題
给你n个二维平面上的点，要求你把他们按照以x轴坐标为第一关键字，y轴坐标为第二关键字的方式从小到大来进行排序。



| 輸入說明                                                     | 輸出說明                                  |
| ------------------------------------------------------------ | ----------------------------------------- |
| 第一行输入一个正整数n。<br />接下来n行，第i行有两个个以空格隔开的正整数x[i]和y[i]，表示第i个点为(x[i],y[i])。 | 输出n行，第i行表示排序好后第i个点的坐标。 |

| 範例輸入 #1                           | 範例輸出 #1                       |
| ------------------------------------- | --------------------------------- |
| 4<br />2 4<br />1 2<br />3 4<br />2 3 | 1 2 <br />2 3 <br />2 4 <br />3 4 |



| 測資資訊：                                                   |
| ------------------------------------------------------------ |
| 記憶體限制： 256 MB<br/>公開 測資點#0 (30%): 1.0s , <1K<br/>公開 測資點#1 (30%): 1.0s , <1K<br/>公開 測資點#2 (40%): 1.0s , <1M |

原題：[a915: 二维点排序 - 高中生程式解題系統 (zerojudge.tw)](https://zerojudge.tw/ShowProblem?problemid=a915)



## 2、解(C++)

一開始在解這一題時嘗試用二維陣列去解，不過越解越煩，直到想起了還有struct這東西後就簡單許多了。

首先弄個struct，裡面有兩個int，分別表x、y。

把資料餵進來後，先對x做排序，再對y做排序(保留x順序的前提下)，之後依照題目的輸出要求輸出即可。

應該還有更好更騷的解法，就留待研究了。

接者，上code ~

```c++
#include <iostream>

struct point
{
	int x, y;
};

int main()
{
	int d = 0;
	point ps[1000];
	while (scanf("%d", &d) != EOF)
	{
		for (int i = 0; i < d; i++)
		{
			point a;
			scanf("%d %d", &a.x, &a.y);
			ps[i] = a;
		}

		//排x軸
		for (int i = 0; i < d; i++)
		{
			for (int j = 0; j < d - 1 - i; j++)
			{
				if (ps[j].x > ps[j + 1].x)
				{
					std::swap(ps[j], ps[j + 1]);
				}
			}
		}

		//排y軸
		for (int i = 0; i < d; i++)
		{
			for (int j = 0; j < d - 1 - i; j++)
			{
				if (ps[j].x == ps[j + 1].x)
				{
					if (ps[j].y > ps[j + 1].y)
					{
						std::swap(ps[j], ps[j + 1]);
					}
				}
			}
		}

		for (int i = 0; i < d; i++)
		{
			printf("%d %d\n", ps[i].x, ps[i].y);
		}
	}

	return 0;
}

```

